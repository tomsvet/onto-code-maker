package ontology.generator.classes.examples.allVariantsOfDatatypeProperties.entities;

import org.eclipse.rdf4j.model.*;
import java.util.List;
import java.util.ArrayList;
import ontology.generator.classes.examples.allVariantsOfDatatypeProperties.Vocabulary;

/**
*  This is the class representing the Class1(http://example.com/Class1) class from ontology
*  This class is subclass of  UnionOfClass1Class2
*
*   Generated by OntoCodeMaker
**/
public class Class1 implements  UnionOfClass1Class2 {

    // IRI instance
    protected IRI iri;
    // IRI Constant of Class
    public static IRI CLASS_IRI = Vocabulary.CLASS1_CLASS_IRI;

    /**
    * Property http://example.com/hasIntFunctionalProp
*  Functional Datatype Property.
*  functional
    **/
    private Integer hasIntFunctionalProp;

    /**
    * Property http://example.com/hasIntInverseFunctionalProp
*  Inverse Functional Datatype Property.
*  inverse functional
    **/
    private List<Integer> hasIntInverseFunctionalProp = new ArrayList<>();

    /**
    * Property http://example.com/hasInt
*  Classic Datatype Property.
    **/
    private List<Integer> hasInt = new ArrayList<>();

    /**
    * Property http://example.com/hasIntFunctionalProp2
*  Functional Datatype Property.
*  functional
    **/
    private Integer hasIntFunctionalProp2;

    /**
    * Property http://example.com/hasIntEquivalentOfFunctional
    * The property is equivalent to hasIntFunctionalProp
*  Equivalent Datatype Property of functional http://example.com/hasIntFunctionalProp.
*  Equivalent Functional
    **/
    private List<Integer> hasIntEquivalentOfFunctional = new ArrayList<>();

    /**
    * Property http://example.com/hasIntSubPropertyOfFunctional
    * The property is SubProperty of  hasIntFunctionalProp
*  SubProperty Datatype Property of functional http://example.com/hasIntFunctionalProp.
*  SubProperty Functional
    **/
    private List<Integer> hasIntSubPropertyOfFunctional = new ArrayList<>();

    /**
    * Property http://example.com/hasIntEquivalent
    * The property is equivalent to hasInt
*  Equivalent Datatype Property to http://example.com/hasInt.
*  Equivalent
    **/
    private List<Integer> hasIntEquivalent = new ArrayList<>();

    /**
    * Property http://example.com/hasIntSubproperty
    * The property is SubProperty of  hasInt
*  SubProperty Datatype Property to http://example.com/hasInt.
*  SubProperty
    **/
    private List<Integer> hasIntSubproperty = new ArrayList<>();

    /**
    * Property http://example.com/domainIsAbstractUnionFunctional. This property is from super class.
*  Functional Datatype property created with Abstract class which is union of Class1 and Class2.
*  Union Of
    **/
    private String domainIsAbstractUnionFunctional;


    public Class1(IRI iri){
            this.iri = iri;
    }

    public IRI getIri(){
        return iri;
    }

    public IRI getClassIRI() {
        return CLASS_IRI;
    }

    public void setHasIntFunctionalProp(Integer hasIntFunctionalProp){
        this.hasIntFunctionalProp = hasIntFunctionalProp;
        if(!this.hasIntEquivalentOfFunctional.contains(hasIntFunctionalProp)){
            this.hasIntEquivalentOfFunctional.add(hasIntFunctionalProp);
        }
    }
    public Integer getHasIntFunctionalProp(){
        return hasIntFunctionalProp;
    }

    public void addHasIntInverseFunctionalProp(Integer hasIntInverseFunctionalProp){
        this.hasIntInverseFunctionalProp.add(hasIntInverseFunctionalProp);
    }
    public List<Integer> getHasIntInverseFunctionalProp(){
        return hasIntInverseFunctionalProp;
    }

    public void addHasInt(Integer hasInt){
        this.hasInt.add(hasInt);
        if(!this.hasIntEquivalent.contains(hasInt)){
            this.hasIntEquivalent.add(hasInt);
        }
    }
    public List<Integer> getHasInt(){
        return hasInt;
    }

    public void setHasIntFunctionalProp2(Integer hasIntFunctionalProp2){
        this.hasIntFunctionalProp2 = hasIntFunctionalProp2;
    }
    public Integer getHasIntFunctionalProp2(){
        return hasIntFunctionalProp2;
    }

    public List<Integer> getHasIntEquivalentOfFunctional(){
        return hasIntEquivalentOfFunctional;
    }

    public void addHasIntSubPropertyOfFunctional(Integer hasIntSubPropertyOfFunctional){
        this.hasIntSubPropertyOfFunctional.add(hasIntSubPropertyOfFunctional);
        if(this.hasIntFunctionalProp == null || !this.hasIntFunctionalProp.equals(hasIntSubPropertyOfFunctional)){
            this.hasIntFunctionalProp = hasIntSubPropertyOfFunctional;
        }
        if(!this.hasIntEquivalentOfFunctional.contains(hasIntSubPropertyOfFunctional)){
            this.hasIntEquivalentOfFunctional.add(hasIntSubPropertyOfFunctional);
        }
    }
    public List<Integer> getHasIntSubPropertyOfFunctional(){
        return hasIntSubPropertyOfFunctional;
    }

    public List<Integer> getHasIntEquivalent(){
        return hasIntEquivalent;
    }

    public void addHasIntSubproperty(Integer hasIntSubproperty){
        this.hasIntSubproperty.add(hasIntSubproperty);
        if(!this.hasInt.contains(hasIntSubproperty)){
            this.hasInt.add(hasIntSubproperty);
        }
        if(!this.hasIntEquivalent.contains(hasIntSubproperty)){
            this.hasIntEquivalent.add(hasIntSubproperty);
        }
    }
    public List<Integer> getHasIntSubproperty(){
        return hasIntSubproperty;
    }


    public void setDomainIsAbstractUnionFunctional(String domainIsAbstractUnionFunctional){
        this.domainIsAbstractUnionFunctional = domainIsAbstractUnionFunctional;
    }
    public String getDomainIsAbstractUnionFunctional(){
        return domainIsAbstractUnionFunctional;
    }

}

