package ontology.generator.classes.examples.allVariantsOfDatatypeProperties.entities;

import org.eclipse.rdf4j.model.*;
import java.util.List;
import java.util.ArrayList;

/**
*   This is an abstract class that represents intersection of  Class2,  Class3.
*  This class is subclass of  Class2,  Class3
*
*   Generated by OntoCodeMaker
**/
public abstract class IntersectionOfClass2Class3 implements  Class2Int, Class3Int {

    // IRI instance
    protected IRI iri;

    /**
    * Property http://example.com/domainIsAbstractIntersectionOfFunctional
*  Functional Datatype property created with abstract class which is Intersection of Class1 and Class2.
*  Abstract Class Intersection Of
    **/
    private String domainIsAbstractIntersectionOfFunctional;

    /**
    * Property http://example.com/hasInt2. This property is from super class.
*  Classic Datatype Property.
    **/
    private List<Integer> hasInt2 = new ArrayList<>();

    /**
    * Property http://example.com/hasInt3. This property is from super class.
*  Classic Datatype Property3.
    **/
    private List<Integer> hasInt3 = new ArrayList<>();

    /**
    * Property http://example.com/hasIntEquivalentOfSubproperty. This property is from super class.
    * The property is equivalent to hasIntSubproperty2
*  Equivalent Datatype Property of subproperty http://example.com/hasIntSubproperty2.
*  Equivalent of Subproperty
    **/
    private List<Integer> hasIntEquivalentOfSubproperty = new ArrayList<>();

    /**
    * Property http://example.com/hasIntEquivalent2. This property is from super class.
    * The property is equivalent to hasInt2
*  Equivalent Datatype Property to http://example.com/hasInt2.
*  Equivalent2
    **/
    private List<Integer> hasIntEquivalent2 = new ArrayList<>();

    /**
    * Property http://example.com/hasIntSubproperty2. This property is from super class.
    * The property is SubProperty of  hasInt3
*  SubProperty Datatype Property to http://example.com/hasInt2.
*  SubProperty2
    **/
    private List<Integer> hasIntSubproperty2 = new ArrayList<>();

    /**
    * Property http://example.com/hasIntEquivalentOfEquivalent. This property is from super class.
    * The property is equivalent to hasIntEquivalent2
*  Equivalent Datatype Property of equivalent http://example.com/hasIntEquivalent.
*  Equivalent of Equivalent
    **/
    private List<Integer> hasIntEquivalentOfEquivalent = new ArrayList<>();

    /**
    * Property http://example.com/hasIntSubpropertyOfEquivalent. This property is from super class.
    * The property is SubProperty of  hasIntEquivalent2
*  SubProperty Datatype Property of equivalent http://example.com/hasIntEquivalent2.
*  SubProperty of Equivalent2
    **/
    private List<Integer> hasIntSubpropertyOfEquivalent = new ArrayList<>();

    /**
    * Property http://example.com/hasIntSubpropertyOfDOubleEquivalents. This property is from super class.
    * The property is SubProperty of  hasIntEquivalentOfEquivalent
*  SubProperty Datatype Property of http://example.com/hasIntEquivalentOfEquivalent.
*  SubProperty of double equivalents
    **/
    private List<Integer> hasIntSubpropertyOfDOubleEquivalents = new ArrayList<>();

    /**
    * Property http://example.com/domainIsAbstractUnionFunctional. This property is from super class.
*  Functional Datatype property created with Abstract class which is union of Class1 and Class2.
*  Union Of
    **/
    private String domainIsAbstractUnionFunctional;


    public IntersectionOfClass2Class3(IRI iri){
            this.iri = iri;
    }

    public IRI getIri(){
        return iri;
    }


    public void setDomainIsAbstractIntersectionOfFunctional(String domainIsAbstractIntersectionOfFunctional){
        this.domainIsAbstractIntersectionOfFunctional = domainIsAbstractIntersectionOfFunctional;
    }
    public String getDomainIsAbstractIntersectionOfFunctional(){
        return domainIsAbstractIntersectionOfFunctional;
    }


    public void addHasInt2(Integer hasInt2){
        this.hasInt2.add(hasInt2);
        if(!this.hasIntEquivalent2.contains(hasInt2)){
            this.hasIntEquivalent2.add(hasInt2);
        }
        if(!this.hasIntEquivalentOfEquivalent.contains(hasInt2)){
            this.hasIntEquivalentOfEquivalent.add(hasInt2);
        }
    }
    public List<Integer> getHasInt2(){
        return hasInt2;
    }
    public void addHasInt3(Integer hasInt3){
        this.hasInt3.add(hasInt3);
        if(!this.hasIntEquivalentOfSubproperty.contains(hasInt3)){
            this.hasIntEquivalentOfSubproperty.add(hasInt3);
        }
    }
    public List<Integer> getHasInt3(){
        return hasInt3;
    }
    public List<Integer> getHasIntEquivalentOfSubproperty(){
        return hasIntEquivalentOfSubproperty;
    }
    public List<Integer> getHasIntEquivalent2(){
        return hasIntEquivalent2;
    }
    public void addHasIntSubproperty2(Integer hasIntSubproperty2){
        this.hasIntSubproperty2.add(hasIntSubproperty2);
        if(!this.hasInt3.contains(hasIntSubproperty2)){
            this.hasInt3.add(hasIntSubproperty2);
        }
        if(!this.hasIntEquivalentOfSubproperty.contains(hasIntSubproperty2)){
            this.hasIntEquivalentOfSubproperty.add(hasIntSubproperty2);
        }
        if(!this.hasIntEquivalentOfSubproperty.contains(hasIntSubproperty2)){
            this.hasIntEquivalentOfSubproperty.add(hasIntSubproperty2);
        }
    }
    public List<Integer> getHasIntSubproperty2(){
        return hasIntSubproperty2;
    }
    public List<Integer> getHasIntEquivalentOfEquivalent(){
        return hasIntEquivalentOfEquivalent;
    }
    public void addHasIntSubpropertyOfEquivalent(Integer hasIntSubpropertyOfEquivalent){
        this.hasIntSubpropertyOfEquivalent.add(hasIntSubpropertyOfEquivalent);
        if(!this.hasIntEquivalent2.contains(hasIntSubpropertyOfEquivalent)){
            this.hasIntEquivalent2.add(hasIntSubpropertyOfEquivalent);
        }
        if(!this.hasInt2.contains(hasIntSubpropertyOfEquivalent)){
            this.hasInt2.add(hasIntSubpropertyOfEquivalent);
        }
        if(!this.hasInt2.contains(hasIntSubpropertyOfEquivalent)){
            this.hasInt2.add(hasIntSubpropertyOfEquivalent);
        }
        if(!this.hasIntEquivalentOfEquivalent.contains(hasIntSubpropertyOfEquivalent)){
            this.hasIntEquivalentOfEquivalent.add(hasIntSubpropertyOfEquivalent);
        }
    }
    public List<Integer> getHasIntSubpropertyOfEquivalent(){
        return hasIntSubpropertyOfEquivalent;
    }
    public void addHasIntSubpropertyOfDOubleEquivalents(Integer hasIntSubpropertyOfDOubleEquivalents){
        this.hasIntSubpropertyOfDOubleEquivalents.add(hasIntSubpropertyOfDOubleEquivalents);
        if(!this.hasIntEquivalentOfEquivalent.contains(hasIntSubpropertyOfDOubleEquivalents)){
            this.hasIntEquivalentOfEquivalent.add(hasIntSubpropertyOfDOubleEquivalents);
        }
        if(!this.hasIntEquivalent2.contains(hasIntSubpropertyOfDOubleEquivalents)){
            this.hasIntEquivalent2.add(hasIntSubpropertyOfDOubleEquivalents);
        }
        if(!this.hasIntEquivalent2.contains(hasIntSubpropertyOfDOubleEquivalents)){
            this.hasIntEquivalent2.add(hasIntSubpropertyOfDOubleEquivalents);
        }
        if(!this.hasInt2.contains(hasIntSubpropertyOfDOubleEquivalents)){
            this.hasInt2.add(hasIntSubpropertyOfDOubleEquivalents);
        }
    }
    public List<Integer> getHasIntSubpropertyOfDOubleEquivalents(){
        return hasIntSubpropertyOfDOubleEquivalents;
    }
    public void setDomainIsAbstractUnionFunctional(String domainIsAbstractUnionFunctional){
        this.domainIsAbstractUnionFunctional = domainIsAbstractUnionFunctional;
    }
    public String getDomainIsAbstractUnionFunctional(){
        return domainIsAbstractUnionFunctional;
    }

}

